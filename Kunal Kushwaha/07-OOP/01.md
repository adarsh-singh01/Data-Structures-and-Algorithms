
# **1. Creating Your Own Data Type Using Classes**

### **Analogy:**

Think of a *class* as a **blueprint** or **mould**, and *objects* as the **actual products** created from that mould.

Example:

* The “Car” design blueprint (class)
* A physical Honda Civic, BMW, etc. (objects)

### **Definition:**

A **class** in Java is a *user-defined data type* that groups together:

* **Properties (fields or variables)** → define the *state* of the object.
* **Methods (functions)** → define the *behavior* of the object.

```java
class Student {
    int roll;
    String name;
    float marks;
}
```

Here:

* `Student` is the **class name** (the *blueprint*).
* `roll`, `name`, and `marks` are **properties** (fields).

---

# **2. Class vs Object**

| Term       | Description                          | Real-world Analogy           |
| ---------- | ------------------------------------ | ---------------------------- |
| **Class**  | Logical definition or template       | “Human” concept              |
| **Object** | Physical instance created from class | Actual person (e.g., Adarsh) |

### **Key Distinctions:**

* **Class** doesn’t exist physically. It’s like a *recipe*.
* **Object** exists physically. It’s like a *cake baked from that recipe*.

```java
Student adarsh = new Student();
```

Here:

* `Student` → the *class type* (like Human).
* `adarsh` → the *object* (like an actual person).

---

# **3. Class as a Template, Object as an Instance**

A **class** provides *structure* — what data and behaviors each object will have.
An **object** is a *concrete example* that actually holds values.

Example:

* Class: `Human`

  * Fields: name, age, height
  * Methods: eat(), sleep(), walk()
* Object:

  * name = “Adarsh”, age = 21, height = 175
  * eat() → prints “Adarsh is eating.”

### **Analogy:**

When babies are born, each baby is an **instance** of the **Human class**.
The concept “Human” is defined by nature (class), but each person (object) is unique.

---

# **4. Object Properties — State, Identity, Behavior**

| Property     | Meaning                              | Example                            |
| ------------ | ------------------------------------ | ---------------------------------- |
| **State**    | Data stored in the object            | name = “Adarsh”, marks = 88.5      |
| **Identity** | Unique reference in memory (address) | `adarsh@3e25a5` (shown by println) |
| **Behavior** | Actions defined by methods           | greeting(), changeName()           |

---

# **5. Accessing Object Members (Dot Operator)**

We use the **dot (.) operator** to access data and methods inside the object.

```java
Student adarsh = new Student();
adarsh.roll = 17;
adarsh.name = "Adarsh Singh";
adarsh.marks = 88.5f;
```

Here:

* `adarsh.roll` accesses the **roll** of that specific student.
* Dot connects **object** → **its member**.

---

# **6. Memory Allocation — Stack and Heap**

When you write:

```java
Student s1 = new Student();
```

**Step-by-step internal process:**

1. **Compile-time (Left-hand side):**

   * `Student s1` → Declares a *reference variable* `s1`.
   * Stored in **stack memory**.
   * It doesn’t yet point to any object.

2. **Runtime (Right-hand side):**

   * `new Student()` → Allocates memory in the **heap** for a new Student object.
   * Initializes all fields with **default values** (`0`, `null`, `0.0f`, etc.).
   * Returns a **reference (address)** of that heap memory.

3. **Assignment:**

   * That reference is stored in the variable `s1` on the stack.
   * So `s1` points to a Student object in heap.

```
STACK                    HEAP
----------------        -----------------------
s1 ---------------->     [Student Object]
                         roll = 0
                         name = null
                         marks = 0.0
```

---

# **7. Multiple Ways to Create Objects**

```java
Student adarsh;
adarsh = new Student();

OR

Student adarsh = new Student();
```

In both cases, the object is created in the heap and `adarsh` points to it.

If you print:

```java
System.out.println(adarsh); // output: Student@3e25a5
System.out.println(adarsh.name); // output: null
```

---

# **8. Constructor — Special Function That Runs at Object Creation**

A **constructor**:

* Has the same name as the class.
* Has no return type.
* Executes automatically when an object is created.
* Used to initialize object variables.

Example:

```java
class Student {
    int rno;
    String name;
    float marks;

    Student() {
        this.rno = 5;
        this.name = "Adarsh Singh";
        this.marks = 88.5f;
    }
}
```

Whenever you call `new Student()`, the constructor sets those default values.

---

# **9. The `this` Keyword — Internal Implementation**

### **Purpose:**

`this` is a **reference variable** that **refers to the current object**.

Whenever you call a method on an object:

```java
adarsh.greeting();
```

Internally, Java passes the **reference of that object** (`adarsh`) as a hidden argument to the method.

So this call:

```java
adarsh.greeting();
```

is internally executed as:

```java
Student.greeting(adarsh);
```

Inside the method, the variable `this` points to the same object:

```java
void greeting() {
    System.out.println("Hello! My name is " + this.name);
}
```

Here `this.name` = `adarsh.name`.

---

### **Why Use `this`:**

* To **distinguish** between instance variables and local variables with the same name.
* To **call another constructor** in the same class.
* To **return current object** (method chaining).

### **Example:**

```java
void changeName(String name) {
    this.name = name; // left: instance var, right: local var
}
```

### **Internal Flow Diagram for `this`:**

```
adarsh.changeName("Arpit");

    |
    v

Inside changeName():
this → reference to adarsh object

this.name = name;
adarsh.name = "Arpit";
```

---

# **10. Constructor Overloading and `this()`**

You can have **multiple constructors** with different parameters — known as *constructor overloading*.

### **Example:**

```java
class Student {
    int rno;
    String name;
    float marks;

    Student() {
        this(13, "Default Person", 100.0f); // calls another constructor
    }

    Student(int rno, String name, float marks) {
        this.rno = rno;
        this.name = name;
        this.marks = marks;
    }

    Student(Student other) {
        this.rno = other.rno;
        this.name = other.name;
        this.marks = other.marks;
    }
}
```

### **Diagram:**

```
new Student()
   ↓
calls → this(13, "Default Person", 100.0f)
   ↓
sets rno=13, name="Default Person", marks=100.0
```

---

# **11. Primitive vs Object Memory Behavior**

| Type          | Stored In                 | Passed By | Example                      |
| ------------- | ------------------------- | --------- | ---------------------------- |
| **Primitive** | Stack                     | Value     | `int x = 10;`                |
| **Object**    | Heap (reference on stack) | Reference | `Student s = new Student();` |

In **Java**, primitives are *not objects* — `int`, `float`, `char` are stored directly in stack.

In **Python**, everything (even integers) is an object, so no `new` keyword is used.

---

# **12. Wrapper Classes**

To make primitives behave like objects, Java provides **Wrapper Classes**:

| Primitive | Wrapper Class |
| --------- | ------------- |
| int       | Integer       |
| float     | Float         |
| char      | Character     |
| boolean   | Boolean       |

Example:

```java
int a = 10;
Integer num = 45; // Auto-boxing
```

---

# **13. Why `swap()` Doesn’t Work with Primitives or Wrapper Classes**

### **For Primitives:**

```java
static void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}
```

→ Doesn’t work because Java is **pass-by-value** — copies of `a` and `b` are passed.

### **For Wrapper Classes:**

```java
static void swap(Integer a, Integer b) {
    Integer temp = a;
    a = b;
    b = temp;
}
```

→ Still doesn’t work because:

1. The *references* are passed by value.
2. `Integer` is **immutable** (`final class`), so its value cannot change.

---

# **14. `final` Keyword and Immutability**

* **`final` variable:** cannot be reassigned.
* **`final` primitive:** value cannot change.
* **`final` object reference:** cannot point to another object, but internal fields *can* change.

Example:

```java
final Student s1 = new Student();
s1.name = "Arpit"; // allowed
s1 = new Student(); // not allowed
```

---

# **15. Garbage Collection and Finalizer**

When an object is **no longer referenced**, it becomes *eligible for garbage collection (GC)*.

You can define a `finalize()` method that runs **before** the object is destroyed (though not guaranteed in modern Java versions).

Example:

```java
class A {
    final int num = 10;
    String name;

    public A(String name) {
        this.name = name;
    }

    @Override
    protected void finalize() throws Throwable {
        System.out.println("Object is destroyed");
    }
}
```

---

# **Summary Table**

| Concept     | Description                                | Example               |
| ----------- | ------------------------------------------ | --------------------- |
| Class       | Logical blueprint                          | `class Student {...}` |
| Object      | Instance of class                          | `new Student()`       |
| this        | Refers to current object                   | `this.name = name;`   |
| Constructor | Initializes object                         | `Student()`           |
| Wrapper     | Object representation of primitives        | `Integer i = 10;`     |
| final       | Prevents reassignment                      | `final int x = 5;`    |
| GC          | Automatically removes unreferenced objects | `finalize()`          |

---

# **Time & Space Notes (Conceptual)**

* **Object creation:** O(1)
* **Accessing fields:** O(1)
* **Memory:**

  * Reference in **stack**
  * Actual object in **heap**

