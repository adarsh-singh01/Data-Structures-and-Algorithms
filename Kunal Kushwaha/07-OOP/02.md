
---

# **1. Packages in Java**

### **Real-World Analogy**

Imagine you have a house with multiple rooms: bedroom, kitchen, bathroom.
Each room contains items with possibly similar names (e.g., “table” in bedroom and kitchen).
To avoid confusion, you *organize* things inside specific compartments.

Similarly, **packages** are compartments (folders) in Java to organize classes and avoid naming conflicts.

---

### **Definition**

A **package** in Java is a **namespace** or **container** that groups related classes and interfaces.

It is essentially a **folder** structure that maps to your system’s directory layout.

Example:

```java
package com.adarsh.packages.a;
```

This means:

* The class is located inside the folder structure
  `/com/adarsh/packages/a/`
* You must save the file accordingly.

---

### **Why Use Packages**

1. **Organize** code logically (group related classes).
2. **Avoid name conflicts** (two developers may have classes with the same name).
3. **Control access** using access modifiers (`public`, `protected`, etc.).
4. **Ease of maintenance** (clean structure).

---

### **Naming Convention**

Packages generally use the **reverse domain name** of the company:

```
Website: adarsh.com
Package: com.adarsh.packages.a
```

So, `com.adarsh` → company’s root package,
and further subpackages organize your modules (like `util`, `db`, etc.)

---

### **Hierarchy Example**

```
src/
 └── com/
     └── adarsh/
         ├── packages/
         │   ├── a/
         │   │   └── MessageA.java
         │   └── b/
         │       └── MessageB.java
```

Inside `MessageA.java`:

```java
package com.adarsh.packages.a;
public class MessageA {
    public static void message() {
        System.out.println("Message from package A");
    }
}
```

Inside another file:

```java
import static com.adarsh.packages.a.MessageA.message;
```

Now you can call:

```java
message();  // instead of MessageA.message();
```

---

### **What is `import`?**

The `import` keyword tells the compiler **where to find** the classes or methods you want to use.

Examples:

```java
import java.util.Arrays;
```

→ Imports the Arrays class from the `java.util` package.

If classes are in **the same folder (package)**, **no import** is required — the compiler already knows their location.

---

### **Static Import**

If you use `import static`, you can access **static members** directly without prefixing with the class name.

```java
import static java.lang.Math.sqrt;
System.out.println(sqrt(16)); // no need to write Math.sqrt
```

---

# **2. The `static` Keyword**

### **Real-World Analogy**

Think of a *population counter* that counts how many Humans exist.
This count doesn’t belong to one particular person — it belongs to the entire species.

Similarly, in Java, **static** members belong to the *class*, not to *individual objects*.

---

### **Definition**

`static` means **shared across all instances**.
It belongs to the **class** itself, not the objects.

You can declare:

* **Static variables** → shared data
* **Static methods** → operations that don’t depend on object data
* **Static blocks** → code executed once per class load

---

### **Example**

```java
public class Human {
    int age;
    String name;
    int salary;
    boolean married;
    static long population;

    public Human(int age, String name, int salary, boolean married) {
        this.age = age;
        this.name = name;
        this.salary = salary;
        this.married = married;
        Human.population += 1;
    }

    static void message() {
        System.out.println("Hello world");
        // Cannot use 'this' here because it's not tied to any object
    }
}
```

---

### **Explanation**

| Member            | Belongs To | Accessed By       | Stored In                |
| ----------------- | ---------- | ----------------- | ------------------------ |
| Non-static fields | Object     | `object.field`    | Heap                     |
| Static fields     | Class      | `ClassName.field` | Method area (JVM memory) |

Every time you create a `Human`, static `population` increases, because it’s **shared**.

```
Human kunal = new Human(22, "Kunal", 10000, false);
Human rahul = new Human(34, "Rahul", 15000, true);
```

Population after both objects = 2

---

### **Why `main` Is Static**

When you run a Java program:

1. JVM starts execution by looking for the `main` method signature:

   ```java
   public static void main(String[] args)
   ```
2. At this point, **no objects exist**.
3. JVM cannot call non-static methods without an object.
4. So, to start execution **without an object**, `main()` must be **static**.

Otherwise, JVM faces a **deadlock**:

> To create object → need to run main → to run main → need object.

Hence, **main() is declared static**.

---

# **3. Static vs Non-static Interaction**

### **Rules**

1. Static methods can access only **static members** directly.
2. Non-static methods can access both static and non-static members.
3. `this` and `super` cannot be used inside static context.

### **Example**

```java
public class Main {
    public static void main(String[] args) {
        Main funn = new Main();
        funn.fun2();
    }

    static void fun() {
        // Cannot call greeting() directly since it's non-static
        Main obj = new Main();
        obj.greeting();
    }

    void fun2() {
        greeting(); // allowed (non-static calling non-static)
    }

    void greeting() {
        System.out.println("Hello world");
    }
}
```

---

# **4. Static Block**

### **Definition**

A **static block** is a block of code that runs **only once** when the class is first loaded into memory.

```java
public class StaticBlockExample {
    static int a;
    static int b;

    static {
        System.out.println("Static block executed");
        a = 10;
        b = 20;
    }

    public static void main(String[] args) {
        System.out.println("Value of a: " + a);
        System.out.println("Value of b: " + b);
    }
}
```

**Output:**

```
Static block executed
Value of a: 10
Value of b: 20
```

**When is it used?**

* Initialize static variables
* Load configuration or constants
* Initialize resources before `main()` executes

---

# **5. Inner Classes**

### **Analogy**

Think of a `Car` class that contains an `Engine` class — the engine is part of the car, not meaningful outside it.

### **Definition**

An **inner class** is a class defined **inside another class**.
It can access all (even private) members of the outer class.

---

### **Example**

```java
public class OuterClass {
    int outerField = 10;

    class InnerClass {
        void display() {
            System.out.println("Outer field is: " + outerField);
        }
    }

    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        OuterClass.InnerClass inner = outer.new InnerClass();
        inner.display();
    }
}
```

**Output:**

```
Outer field is: 10
```

---

### **How It Works Internally**

* When you create an `InnerClass`, it is *attached* to a specific instance of `OuterClass`.
* The compiler secretly stores a reference to the **outer instance** inside the inner object.

Diagram:

```
OuterClass object (outer)
   ↓
   holds reference to InnerClass instance
InnerClass object (inner)
   ↳ hidden link to outer
```

That’s why `inner` can access `outerField` even if it’s private.

---

### **Types of Inner Classes**

| Type                       | Description                               | Can be static? |
| -------------------------- | ----------------------------------------- | -------------- |
| **Non-static Inner Class** | Needs an instance of outer class          | No             |
| **Static Nested Class**    | Does not need outer instance              | Yes            |
| **Local Inner Class**      | Declared inside a method                  | No             |
| **Anonymous Inner Class**  | Class without name (used in GUI, threads) | No             |

---

### **Static Inner Class Example**

```java
public class Outer {
    static int outerStatic = 100;

    static class Inner {
        void display() {
            System.out.println("Outer static: " + outerStatic);
        }
    }

    public static void main(String[] args) {
        Outer.Inner obj = new Outer.Inner();
        obj.display();
    }
}
```

Here, `Inner` does not depend on any `Outer` object.

---

# **6. Internal Working of `System.out` and `System.in`**

### **System**

`System` is a **final class** in the `java.lang` package that cannot be instantiated.

Inside `System`:

```java
public final class System {
    public static final PrintStream out;
    public static final InputStream in;
    // many other fields...
}
```

* `System.out` is a **static** variable of type `PrintStream`.
* It points to the **standard output stream**, usually the **console**.
* `System.in` is a **static InputStream** tied to keyboard input.

Internally, these are initialized in a static block when JVM loads `System` class:

```java
static {
    out = new PrintStream(...);
    in = new BufferedInputStream(...);
}
```

So when you do:

```java
System.out.println("Hello");
```

* `System` → Class
* `out` → Static field (shared PrintStream object)
* `println()` → Method of `PrintStream`
  That’s why you can print **without creating any object** of `System`.

---

### **Why It Prints `com.adarsh@hshsu88`**

Whenever you `print` an object directly:

```java
System.out.println(obj);
```

It calls `obj.toString()`.

If you haven’t overridden `toString()` in your class, Java uses the default one from `Object` class:

```java
getClass().getName() + "@" + Integer.toHexString(hashCode())
```

So, `com.adarsh@hshsu88` means:

* `com.adarsh` = class name
* `hshsu88` = hex version of object’s hash code (like an internal ID)

---

# **7. Singleton Class**

### **Analogy**

Think of your operating system’s task manager — you only need *one* instance of it.
If multiple existed, system data would get corrupted.

---

### **Definition**

A **Singleton** class allows **only one object** to exist during the entire program lifecycle.

### **Why Use It**

* Manage shared resources (database, configuration, loggers)
* Ensure global control

---

### **Implementation**

```java
class Singleton {
    private static Singleton instance;

    private Singleton() {
        // private constructor to prevent external instantiation
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

Usage:

```java
Singleton obj1 = Singleton.getInstance();
Singleton obj2 = Singleton.getInstance();
System.out.println(obj1 == obj2); // true
```

### **Explanation**

* Constructor is `private` → No one can create an object using `new`.
* `instance` is `static` → Only one copy shared among all.
* `getInstance()` ensures a single object is created lazily.

---

### **Memory Diagram**

```
STACK               HEAP
----------------   -----------------------
obj1 ------------> [Singleton instance]
obj2 ------------>  ↑ (same reference)
                    |
                  Singleton.instance
```

---

### **Variants of Singleton**

1. **Eager Initialization**

   ```java
   private static final Singleton instance = new Singleton();
   ```

   Created as soon as the class loads.
2. **Lazy Initialization**
   Created only when needed (as shown above).
3. **Thread-safe Singleton**

   ```java
   public static synchronized Singleton getInstance() { ... }
   ```

   Ensures safe access in multithreaded programs.

---

# **Summary Table**

| Concept          | Meaning                           | Example                    |
| ---------------- | --------------------------------- | -------------------------- |
| **Package**      | Folder-like structure for classes | `package com.adarsh.util;` |
| **Import**       | Allows using external classes     | `import java.util.*;`      |
| **Static**       | Belongs to class, not object      | `static int population;`   |
| **Static Block** | Runs once when class loads        | Initialize constants       |
| **Inner Class**  | Class inside another              | `Outer.Inner inner = ...`  |
| **System.out**   | Static PrintStream for console    | `System.out.println()`     |
| **Singleton**    | One instance only                 | `Singleton.getInstance()`  |

---

