
---

# **1. Custom ArrayList (Manual Implementation)**

### **Real-world Analogy**

Think of a dynamic bookshelf:

* Initially, it has 5 empty slots.
* If you add more books than it can hold, you buy a bigger shelf and move all books to it.
  That’s exactly how `ArrayList` works internally.

---

### **Goal**

Implement our own `CustomArrayList` that:

* Stores elements dynamically.
* Doubles its capacity when full.
* Provides `add()`, `remove()`, `get()`, and `size()` methods.

---

### **Step-by-Step Implementation**

```java
public class CustomArrayList {
    private int[] data;
    private static int DEFAULT_SIZE = 10;
    private int size = 0;  // how many elements are actually stored

    public CustomArrayList() {
        this.data = new int[DEFAULT_SIZE];
    }

    public void add(int num) {
        if (isFull()) {
            resize();
        }
        data[size++] = num;
    }

    private boolean isFull() {
        return size == data.length;
    }

    private void resize() {
        int[] temp = new int[data.length * 2];
        for (int i = 0; i < data.length; i++) {
            temp[i] = data[i];
        }
        data = temp;
    }

    public int remove() {
        int removed = data[--size];
        return removed;
    }

    public int get(int index) {
        return data[index];
    }

    public int size() {
        return size;
    }

    public void display() {
        for (int i = 0; i < size; i++) {
            System.out.print(data[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        CustomArrayList list = new CustomArrayList();
        list.add(3);
        list.add(5);
        list.add(9);
        list.display();
    }
}
```

---

### **ASCII Diagram of Internal Working**

```
Initial state (size=0, capacity=10)
[_, _, _, _, _, _, _, _, _, _]

After add(3), add(5), add(9)
[3, 5, 9, _, _, _, _, _, _, _]
         ↑
        size = 3

When full → resize() doubles capacity:
Old = 10 → New = 20
Data copied to new array.
```

---

### **Key Concept**

ArrayList uses **amortized O(1)** addition because resizing happens infrequently (capacity ×2).
`remove()` and `get()` are **O(1)** (end) and `O(n)` (middle deletions).

---

# **2. Custom ArrayList with Generics**

### **Motivation**

The above implementation only works for `int`.
Generics allow our data structure to work with *any type* (`Integer`, `String`, `Student`, etc.) while ensuring *type safety*.

---

### **Generic Version**

```java
public class CustomGenericArrayList<T> {
    private Object[] data;
    private static int DEFAULT_SIZE = 10;
    private int size = 0;

    public CustomGenericArrayList() {
        data = new Object[DEFAULT_SIZE];
    }

    public void add(T value) {
        if (isFull()) resize();
        data[size++] = value;
    }

    private boolean isFull() {
        return size == data.length;
    }

    private void resize() {
        Object[] temp = new Object[data.length * 2];
        System.arraycopy(data, 0, temp, 0, data.length);
        data = temp;
    }

    public T get(int index) {
        return (T) data[index];  // type casting
    }

    public int size() {
        return size;
    }

    public void display() {
        for (int i = 0; i < size; i++) {
            System.out.print(data[i] + " ");
        }
        System.out.println();
    }
}
```

Usage:

```java
CustomGenericArrayList<String> names = new CustomGenericArrayList<>();
names.add("Adarsh");
names.add("Kunal");
names.display();
```

---

### **Concept: Type Erasure**

Generics exist only at compile-time.
The compiler ensures type safety but removes (`erases`) type parameters at runtime — turning `T` into `Object`.

Example:

```java
CustomGenericArrayList<Integer> list = new CustomGenericArrayList<>();
// Compiles type-safely, but internally uses Object[]
```

---

# **3. Working with Generics**

### **What are Generics?**

Generics allow *parameterized types* — defining classes, methods, or interfaces with type placeholders.
They make code *type-safe*, *reusable*, and *cleaner*.

---

### **Example 1 — Generic Class**

```java
class Box<T> {
    private T value;
    public void set(T value) { this.value = value; }
    public T get() { return value; }
}
```

Usage:

```java
Box<Integer> intBox = new Box<>();
intBox.set(10);
System.out.println(intBox.get());  // 10
```

---

### **Example 2 — Generic Method**

```java
class Printer {
    public <T> void print(T[] array) {
        for (T item : array)
            System.out.print(item + " ");
        System.out.println();
    }
}
```

Usage:

```java
Printer p = new Printer();
p.<Integer>print(new Integer[]{1, 2, 3});
p.print(new String[]{"A", "B", "C"});
```

---

### **Example 3 — Multiple Type Parameters**

```java
class Pair<K, V> {
    private K key;
    private V value;
    public Pair(K key, V value) {
        this.key = key; this.value = value;
    }
}
```

Usage:

```java
Pair<String, Integer> p = new Pair<>("Age", 25);
```

---

# **4. Wildcards in Generics**

### **Concept**

Wildcards (`?`) allow *flexible* references for generic types when you don't know the exact type parameter but want to accept a range of them.

---

### **Types of Wildcards**

| Type              | Syntax          | Meaning                          |
| ----------------- | --------------- | -------------------------------- |
| **Unbounded**     | `<?>`           | Any type allowed (unknown type). |
| **Upper-bounded** | `<? extends T>` | Accepts T or any subtype of T.   |
| **Lower-bounded** | `<? super T>`   | Accepts T or any supertype of T. |

---

### **Examples**

1. **Unbounded Wildcard**

```java
public void printList(List<?> list) {
    for (Object obj : list) System.out.println(obj);
}
```

You can pass `List<Integer>`, `List<String>`, etc.

---

2. **Upper-Bounded Wildcard**

```java
public static double sumOfNumbers(List<? extends Number> list) {
    double sum = 0;
    for (Number n : list) sum += n.doubleValue();
    return sum;
}
```

You can pass `List<Integer>`, `List<Float>`, `List<Double>`.

---

3. **Lower-Bounded Wildcard**

```java
public static void addNumbers(List<? super Integer> list) {
    list.add(10); list.add(20);
}
```

You can pass `List<Integer>`, `List<Number>`, `List<Object>`.

---

### **PECS Rule (Producer Extends, Consumer Super)**

* **Producer Extends**: If your generic produces data — use `extends`.
* **Consumer Super**: If it consumes (you add elements) — use `super`.

---

# **5. Comparing Objects (Comparable & Comparator)**

### **Why we need it**

When we want to sort or compare objects (e.g., students by marks), we must define *how* one object compares to another.

---

### **Comparable Interface**

Used for **natural ordering**.
Defines `compareTo(T o)` method.

```java
class Student implements Comparable<Student> {
    int roll;
    float marks;

    Student(int roll, float marks) {
        this.roll = roll; this.marks = marks;
    }

    @Override
    public int compareTo(Student other) {
        return Float.compare(this.marks, other.marks);
    }

    @Override
    public String toString() {
        return "Student{" + roll + ", marks=" + marks + '}';
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(1, 78.5f));
        list.add(new Student(2, 89.5f));
        Collections.sort(list); // uses compareTo()
        System.out.println(list);
    }
}
```

---

### **Comparator Interface**

Used for **custom ordering** — especially if you cannot modify the original class.

```java
Comparator<Student> byRoll = (a, b) -> a.roll - b.roll;
Collections.sort(list, byRoll);
```

---

### **ASCII Flow: Comparable vs Comparator**

```
Comparable (inside class)
  ↓
obj1.compareTo(obj2)

Comparator (external)
  ↓
comparator.compare(obj1, obj2)
```

---

# **6. Lambda Expressions**

### **Definition**

A *lambda* is a short form of anonymous function — introduced in Java 8 to simplify passing behavior (usually where functional interfaces are expected).

---

### **Functional Interface**

An interface with exactly **one abstract method**.

Example:

```java
@FunctionalInterface
interface Operation {
    int operate(int a, int b);
}
```

---

### **Lambda Example**

```java
Operation sum = (a, b) -> a + b;
Operation multiply = (a, b) -> a * b;

System.out.println(sum.operate(5, 6));       // 11
System.out.println(multiply.operate(5, 6));  // 30
```

---

### **Why useful**

* Reduces boilerplate (no anonymous class).
* Used in streams, comparators, threading, etc.

---

### **Example with Comparator**

```java
Collections.sort(list, (a, b) -> Float.compare(a.marks, b.marks));
```

---

# **7. Exception Handling**

### **Concept**

An **exception** is an unwanted event that disrupts program flow.
Java handles it using **try-catch-finally** blocks.

---

### **Hierarchy**

```
Throwable
 ├── Exception  (checked)
 │    ├── IOException
 │    └── SQLException
 └── RuntimeException  (unchecked)
      ├── NullPointerException
      ├── IndexOutOfBoundsException
      └── ArithmeticException
```

---

### **Example**

```java
try {
    int a = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Divide by zero not allowed");
} finally {
    System.out.println("Always executes");
}
```

---

# **8. Creating Custom Exceptions**

### **Why**

To handle application-specific scenarios (e.g., invalid age, insufficient balance).

---

### **Example**

```java
class AgeException extends Exception {
    public AgeException(String msg) {
        super(msg);
    }
}

public class Main {
    public static void main(String[] args) {
        try {
            validateAge(15);
        } catch (AgeException e) {
            System.out.println("Exception: " + e.getMessage());
        }
    }

    static void validateAge(int age) throws AgeException {
        if (age < 18) throw new AgeException("Age must be 18+ to vote");
    }
}
```

---

# **9. Object Cloning**

### **Concept**

Cloning means creating a **copy** of an object with the same state.

Java supports cloning via `Object.clone()` method.

---

### **Shallow Copy**

Copies field values **as-is**.
If fields refer to other objects, the references are copied, not the objects.

---

### **Deep Copy**

Copies all fields, and **recursively copies referenced objects**.

---

### **Example**

```java
class Human implements Cloneable {
    int age;
    String name;
    int[] arr;

    Human(int age, String name) {
        this.age = age;
        this.name = name;
        this.arr = new int[]{1, 2, 3};
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        // Shallow copy
        return super.clone();
    }
}

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Human adarsh = new Human(22, "Adarsh");
        Human twin = (Human) adarsh.clone();

        twin.arr[0] = 99;  // modifies both
        System.out.println(Arrays.toString(adarsh.arr)); // [99, 2, 3]
    }
}
```

---

### **Deep Copy Implementation**

```java
@Override
public Object clone() throws CloneNotSupportedException {
    Human twin = (Human) super.clone();
    twin.arr = arr.clone();  // deep copy array
    return twin;
}
```

Now modifications in `twin.arr` don’t affect `adarsh.arr`.

---

### **ASCII Visualization**

```
Shallow Copy:
adarsh.arr ─┐
             ├──► [1, 2, 3]
twin.arr ────┘

Deep Copy:
adarsh.arr ───► [1, 2, 3]
twin.arr   ───► [1, 2, 3] (new array)
```

---

### **Rules for Cloning**

1. Class must implement `Cloneable` (marker interface).
2. Override `clone()` method (make it public).
3. Call `super.clone()` (it performs shallow copy).
4. For deep copy, clone mutable fields manually.

---

# **10. Summary Table**

| Concept              | Purpose                          | Example / Keyword                     | Key Points                 |
| -------------------- | -------------------------------- | ------------------------------------- | -------------------------- |
| **Custom ArrayList** | Implement dynamic array manually | resizing array                        | Doubles capacity when full |
| **Generics**         | Type-safe, reusable code         | `<T>`                                 | Type erasure at runtime    |
| **Wildcards**        | Flexible generics                | `<?>`, `<? extends T>`, `<? super T>` | Use PECS rule              |
| **Comparable**       | Natural ordering                 | `compareTo()`                         | Implemented in class       |
| **Comparator**       | External comparison              | `compare(a,b)`                        | Lambda often used          |
| **Lambda**           | Short anonymous function         | `(a,b)->a+b`                          | Functional interfaces      |
| **Exception**        | Handle runtime errors            | `try-catch`                           | Checked vs unchecked       |
| **Custom Exception** | App-specific error               | `extends Exception`                   | Use `throw`                |
| **Cloning**          | Copy objects                     | `clone()`, `Cloneable`                | Shallow vs deep copy       |

---

