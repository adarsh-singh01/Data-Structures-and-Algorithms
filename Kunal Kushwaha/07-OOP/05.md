

# 1 — Abstract classes

### Analogy

An **abstract class** is like a partially finished blueprint for a family of products. It defines common parts (framework) and leaves some methods as “you must implement this” — like a machine blueprint that says “every model must implement how it starts”, but provides shared code for cooling or control logic.

### Definition

An **abstract class** is a class that:

* is declared with the `abstract` keyword, and
* cannot be instantiated directly.
  It may contain:
* **abstract methods** (method signatures without a body) that concrete subclasses must implement, and
* **concrete methods** (with bodies), fields, constructors, and static members.

> *Important:* An abstract class does not require having abstract methods — the `abstract` modifier alone makes it non-instantiable.

### Why use an abstract class

* Share common state (fields) and behavior (concrete methods) among related classes.
* Force subclasses to implement specific behavior (abstract methods).
* Provide a common base type so code can operate on `ParentType` without knowing concrete types.

### Rules, restrictions & internals

* You **cannot instantiate** an abstract class: `new Parent()` is illegal.
* A concrete subclass *must* implement all abstract methods, unless the subclass is also `abstract`.
* Constructors: abstract classes **can** have constructors — they are executed when subclasses are instantiated to initialize parent part.
* `abstract` static methods are **not allowed** (static methods cannot be overridden and abstract implies overriding).
* `abstract final` impossible: `final` prevents overriding; `abstract` requires it.
* Access modifiers on abstract methods work like normal methods (e.g., `protected abstract void doTask();`).
* Abstract class may implement interfaces and provide default implementations.

### Example (refined from your notes)

```java
package com.adarsh.abstractdemo;

public abstract class Parent {
    int age;
    final int VALUE;

    public Parent(int age) {
        this.age = age;
        this.VALUE = 32456789;
    }

    static void hello() {
        System.out.println("hey");
    }

    void normal() {
        System.out.println("this is a normal method");
    }

    // abstract methods — must be implemented by non-abstract subclasses
    abstract void career();
    abstract void partner();
}
```

Concrete subclasses:

```java
package com.adarsh.abstractdemo;

public class Son extends Parent {
    public Son(int age) { super(age); }

    @Override
    void career() { System.out.println("I am going to be a doctor"); }

    @Override
    void partner() { System.out.println("I love Pepper Potts"); }
}

public class Daughter extends Parent {
    public Daughter(int age) { super(age); }

    @Override
    void career() { System.out.println("I am going to be a coder"); }

    @Override
    void partner() { System.out.println("I love Iron Man"); }
}
```

Usage:

```java
public class Main {
    public static void main(String[] args) {
        Son son = new Son(30);
        son.career();    // doctor
        son.normal();    // inherited concrete method

        Parent mom = new Daughter(28);
        mom.career();    // Daughter's implementation (polymorphism)
        Parent.hello();  // static method can be called on the class
    }
}
```

### Constructor flow (ASCII)

```
new Daughter(28)
  -> Daughter constructor
     -> super(28)  // Parent constructor called first
        -> Parent fields initialized
     -> Daughter constructor body runs
```

### Interview patterns & pitfalls

* Be ready to explain why abstract classes can have constructors.
* Use abstract classes when children share common state or methods; use interfaces when only a capability/contract is required.
* Don’t confuse `abstract` with `interface` (they’re related but different — see below).
* If subclass fails to implement abstract methods, the compiler forces subclass to be abstract too.

---

# 2 — Interfaces

### Analogy

An **interface** is a contract or role card: “If you implement this card, you must provide these behaviors.” Think of capability badges: `Drivable`, `Flyable`, `Serializable`. A class can collect many badges.

### Definition (modern Java)

An **interface** is a reference type that can declare:

* **abstract method signatures** (pre-Java 8 these were the only methods),
* **default methods** (with bodies — introduced in Java 8),
* **static methods** (with bodies),
* **private methods** (allowed since Java 9, for internal reuse inside the interface),
* **constant fields** (implicitly `public static final`),
* **nested types** (interfaces, classes, enums).

A class uses `implements` to claim it fulfills the interface contract.

### Why use interfaces

* Represent capabilities/roles (composition of behavior).
* Achieve multiple inheritance of type (a class can implement many interfaces).
* Decouple code via abstraction (code depends on the interface, not the concrete implementation).
* Add functionality to existing classes without changing their class hierarchy.

### Key rules & details

* Interface methods without body are implicitly `public abstract` (unless default/static/private).
* Fields in an interface are implicitly `public static final` (constants).
* `implements` vs `extends`: classes `implement` interfaces; interfaces `extend` other interfaces.
* A class can implement multiple interfaces, enabling multiple type inheritance.
* Default methods allow adding behavior to interfaces without breaking existing implementors (used in Java 8 for API evolution — e.g., `Iterable.forEach`).
* If multiple interfaces provide the same default method, the implementing class must override it and resolve the conflict. Class methods (inheritance) take precedence over interface defaults.
* `static` interface methods are called via `InterfaceName.method()` and are not inherited by implementing classes.
* `private` interface methods are for code reuse inside the interface (not accessible to implementors).

### Car / Brake / Engine / Media example

Define three interfaces:

```java
public interface Engine {
    void start();
    void stop();
}

public interface Brake {
    void apply();
    void release();
}

public interface MediaSystem {
    void play();
    void stop();            // note: name conflict with Engine.stop()
}
```

Implementations:

```java
public class PetrolEngine implements Engine {
    public void start()  { System.out.println("Petrol engine starting"); }
    public void stop()   { System.out.println("Petrol engine stopping"); }
}

public class ElectricEngine implements Engine {
    public void start()  { System.out.println("Electric engine starting silently"); }
    public void stop()   { System.out.println("Electric engine stopping"); }
}

public class ABSBrake implements Brake {
    public void apply()  { System.out.println("ABS applying"); }
    public void release(){ System.out.println("ABS released"); }
}

public class BasicMedia implements MediaSystem {
    public void play() { System.out.println("Playing audio"); }
    public void stop() { System.out.println("Media stopped"); }
}
```

A `Car` can implement multiple interfaces or hold them as components (composition):

```java
// Composition approach preferred
public class Car {
    private final Engine engine;
    private final Brake brake;
    private final MediaSystem media;

    public Car(Engine engine, Brake brake, MediaSystem media) {
        this.engine = engine; this.brake = brake; this.media = media;
    }

    public void drive() {
        engine.start();
        media.play();
    }

    public void park() {
        brake.apply();
        engine.stop();
        media.stop();
    }
}
```

Usage:

```java
Car petrolCar = new Car(new PetrolEngine(), new ABSBrake(), new BasicMedia());
petrolCar.drive();
```

### Default method conflict & resolution (diamond of default methods)

If two interfaces define the same default method:

```java
interface A {
    default void stop() { System.out.println("A.stop"); }
}
interface B {
    default void stop() { System.out.println("B.stop"); }
}

class MyCar implements A, B {
    // Must override to resolve conflict
    @Override
    public void stop() {
        A.super.stop(); // or B.super.stop(); or a new implementation
    }
}
```

### Interface inheritance

* Interfaces can extend other interfaces:

```java
interface Vehicle extends Engine, Brake { }
```

* An interface can extend multiple interfaces.

### Functional interfaces

* An interface with a single abstract method (SAM) is a functional interface and can be instantiated with a lambda (e.g., `Runnable`, `Callable`, `Consumer`).
* Annotate with `@FunctionalInterface` (optional but helpful).

### When to prefer interface vs abstract class

* Use **interface** when you need multiple inheritance of type or just a contract with no shared state.
* Use **abstract class** when you need to share implementation and state among closely related classes.

### Interview patterns & pitfalls

* Understand and explain the default method conflict resolution rules.
* Know that interfaces can have `private` methods since Java 9.
* Know that static interface methods are not inherited; call them as `InterfaceName.method()`.
* Prefer composition (has-a) for reusability; interfaces for capability.

---

# 3 — Annotations

### Analogy

Annotations are sticky notes attached to code that supply metadata: information about the code that tools, the compiler, or frameworks can read and act on (for validation, code generation, or runtime behavior).

### Definition

An **annotation** is metadata you attach to declarations (classes, methods, fields, parameters, packages, local variables, etc.). Annotations themselves are defined as `@interface` types.

Annotations by themselves do not change program semantics — but tools, frameworks, and the JVM (for certain built-in annotations) can interpret them.

### Common built-in annotations

* `@Override` — compile-time check that a method overrides a superclass method.
* `@Deprecated` — marks that a program element should no longer be used; compiler warns on usage.
* `@SuppressWarnings("unchecked")` — ask compiler to suppress specific warnings.
* `@SafeVarargs` — suppress unsafe warnings for varargs on final or static methods.
* `@FunctionalInterface` — indicates SAM interface intended for lambdas.
* `@Retention`, `@Target`, `@Inherited`, `@Repeatable` — meta-annotations that describe annotation behavior.

### Retention & Target (meta-annotations)

When you define an annotation, you specify:

* **RetentionPolicy** — how long the annotation is available:

  * `SOURCE` — only in source code, discarded by compiler.
  * `CLASS` — recorded in class file but not available at runtime.
  * `RUNTIME` — available at runtime via reflection.
* **@Target** — where the annotation can be used: `TYPE`, `METHOD`, `FIELD`, `PARAMETER`, `CONSTRUCTOR`, etc.
* **@Inherited** — if present on a class annotation, subclasses inherit that annotation (applies only to class-level annotations).
* **@Repeatable** — allow multiple instances of the same annotation on a single element.

### Defining a custom annotation

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)                 // can annotate classes / interfaces
public @interface MyService {
    String name();
    int version() default 1;
}
```

Usage:

```java
@MyService(name = "payment", version = 2)
public class PaymentService { ... }
```

Reading at runtime via reflection:

```java
MyService ann = PaymentService.class.getAnnotation(MyService.class);
if (ann != null) {
    System.out.println(ann.name() + " v" + ann.version());
}
```

### Processing annotations

* **Runtime processing** — frameworks like Spring read runtime annotations via reflection.
* **Compile-time processing** — using the Annotation Processing Tool (APT) / `javax.annotation.processing` (`Processor`) to generate code, validation, or resources at compile time (used by Lombok, Dagger, etc.).

### Marker and single-value annotations

* **Marker annotation**: no elements, just a tag (e.g., `@Override` is technically not a marker but a built-in with compiler behavior). Example: `@Entity` might be a marker telling a framework this class is a database entity.
* **Single-element annotation**: if annotation has single element named `value`, you can write `@Ann("x")` instead of `@Ann(value="x")`.

### Example — repeatable annotation

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Tags.class)
public @interface Tag { String value(); }

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Tags { Tag[] value(); }

// usage
@Tag("fast")
@Tag("core")
public void doWork() { ... }
```

### Common uses in frameworks

* Dependency injection (`@Inject`, `@Autowired`)
* ORM mapping (`@Entity`, `@Table`, `@Column`)
* Web controllers (`@Controller`, `@RequestMapping`)
* Validation (`@NotNull`, `@Size`)

### Interview patterns & pitfalls

* Know retention policies and when annotation is available.
* Understand difference between source-only annotations (like `@Override`) and runtime annotations used by frameworks.
* Be able to write a simple annotation and read it via reflection.
* Understand compile-time annotation processors (APT) vs runtime reflection.

---

# 4 — Interactions and examples: Abstract class vs Interface vs Annotation

### When to choose:

* **Abstract class**: common state + behavior, classes are closely related (share `protected` fields, helper methods), only single inheritance needed.
* **Interface**: capability contract, multiple unrelated classes should share behavior type, no shared state required.
* **Annotation**: metadata, not behavior. Use when you want frameworks/tools/compilers to act on code elements.

### Example set: Car domain (combining all three)

Abstract base (shared fields):

```java
public abstract class Vehicle {
    private final String vin;
    protected String model;

    protected Vehicle(String vin, String model) {
        this.vin = vin;
        this.model = model;
    }

    public String getVin() { return vin; }

    // shared method
    public void info() {
        System.out.println("VIN: " + vin + ", model: " + model);
    }

    // contract for subclasses
    public abstract void drive();
}
```

Interfaces:

```java
public interface Engine {
    void start();
    void stop();
}

public interface Brake {
    void apply();
    void release();
}
```

Concrete class:

```java
public class ElectricCar extends Vehicle implements Engine, Brake {
    public ElectricCar(String vin, String model) { super(vin, model); }

    @Override
    public void drive() { start(); System.out.println("Electric car driving"); }

    @Override public void start() { System.out.println("Electric motor start"); }
    @Override public void stop()  { System.out.println("Electric motor stop"); }
    @Override public void apply() { System.out.println("Regenerative braking applied"); }
    @Override public void release(){ System.out.println("Brakes released"); }
}
```

Annotation to mark services:

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Service { String name(); }

@Service(name="charging")
public class ChargerService { ... }
```

Reflection usage:

```java
Service s = ChargerService.class.getAnnotation(Service.class);
System.out.println(s.name());
```

---

# 5 — ASCII diagrams

## Inheritance vs Implements

```
   [Abstract class Vehicle]         [Interface Engine]
   -----------------------          ------------------
   - vin: String                    + start()
   - model: String                  + stop()
   + info()                         (no fields)
   + abstract drive()

             ^
             | extends
             |
   [ElectricCar]  ---- implements ----> [Engine]
   - overrides drive()                     - implements start(), stop()
   - implements braking (Brake)
```

## Method resolution with default methods

```
Interface A { default void x() { A } }
Interface B { default void x() { B } }
Class C implements A,B {  // conflict
   @Override void x() { A.super.x(); }  // explicit resolution
}
```

---

# 6 — Quick interview checklist

* You can explain constructor invocation order for abstract class → subclass.
* You can list what an interface may contain (constants, abstract methods, default, static, private methods).
* You can demonstrate a default method conflict and show how to resolve it (override + call `InterfaceName.super.method()`).
* You can explain functional interfaces and show a lambda example.
* You can write a simple custom annotation, explain retention and target, and show how to read it via reflection.
* You can state when to use interface vs abstract class (shared state + behavior → abstract class; multiple capabilities → interfaces).
* Know that interfaces are preferable when you need multiple inheritance of type; classes are single-inheritance.

---

# 7 — Common pitfalls & corrections to your rough notes (explicit)

* **“In interfaces, all methods are implicitly public and abstract”** — this was true prior to Java 8 for non-default/non-static methods; now interfaces can have `default`, `static`, and `private` methods. Non-`default`/non-`static`/non-`private` methods are implicitly `public abstract`.
* **“You cannot have private or protected methods in an interface”** — since Java 9 interfaces may declare `private` methods (useful inside the interface for code reuse). Protected is still not applicable.
* **“Interface variables are implicitly public, static and final”** — correct.
* **“Static interface methods must have a body”** — correct (static methods are concrete).
* **“Interfaces can be nested inside classes and other interfaces”** — correct.
* **“Abstract classes cannot have constructors”** — incorrect; they can and usually do (for initializing inherited state).
* **“You cannot create abstract constructors”** — correct (constructors cannot be abstract).
* **“You cannot declare abstract static methods”** — correct.
* **“An interface cannot contain instance fields or constructors”** — correct; it can only have constants (`public static final` fields).
* **“Interfaces disconnect methods from class hierarchy, can add functionality to existing class”** — correct (default methods help API evolution).
* **“If two interfaces have the same method name (like stop), default methods may cause confusion”** — correct; resolution rules require explicit override.

---

# 8 — Final concise summary

* **Abstract class**: partial implementation + possible abstract methods. Use when related classes share state/storage or common code.
* **Interface**: pure contract (plus default/static/private helper methods). Use for capabilities and to allow multiple type inheritance.
* **Annotation**: metadata for tools/compilers/runtimes. Define via `@interface`, set retention and targets, and read via reflection or annotation processors.
