
---

# Java Collection Framework — Deep, detailed notes

## 1. What is the Collection Framework?

**Definition (concise):**
The Java Collection Framework (JCF) is a unified architecture of interfaces and concrete classes for storing and manipulating groups of objects. It provides standard data structures (lists, sets, queues, maps) and algorithms (searching, sorting, iteration), plus utilities in `java.util` (Collections, Arrays) that work consistently across implementations.

**Why it matters:**

* Reuses well-tested, optimized data structures.
* Gives common APIs so code can switch implementations easily.
* Improves code readability and correctness.
* Offers specialized implementations for concurrency, ordering, uniqueness, and performance needs.

---

## 2. High-level architecture (ASCII)

```
java.lang.Object
     |
  ---------------------------
  |                         |
java.util.Collection       java.util.Map   (Map is not a Collection)
  |                         |
  |-- List                  |-- SortedMap
  |    |-- ArrayList        |    |-- TreeMap
  |    |-- LinkedList       |    |-- NavigableMap
  |    |-- Vector           |-- HashMap
  |    |-- CopyOnWriteArrayList
  |
  |-- Set
  |    |-- HashSet
  |    |-- LinkedHashSet
  |    |-- TreeSet (SortedSet/NavigableSet)
  |
  |-- Queue
       |-- Deque
           |-- ArrayDeque
           |-- LinkedList (implements Deque)
       |-- PriorityQueue

Other utilities:
- Collections (static helpers)
- Arrays (static helpers)
- Iterator / ListIterator
- Spliterator, Stream support
```

> Note: `Map` is a separate root interface (not extending `Collection`) because a `Map` holds key→value mappings rather than just elements.

---

## 3. Core interfaces and their semantic contracts

* **Collection<E>** — root interface for groups of objects (size, add, remove, iterator).
* **List<E>** — ordered sequence, indexed access, may contain duplicates. Implementations: `ArrayList`, `LinkedList`, `Vector`, `CopyOnWriteArrayList`.
* **Set<E>** — no duplicate elements. Implementations: `HashSet`, `LinkedHashSet`, `TreeSet` (sorted).
* **Queue<E>** — FIFO semantics; also supports priority ordering (`PriorityQueue`). `Deque<E>` is double-ended queue.
* **Map<K,V>** — key→value mappings. Implementations: `HashMap`, `LinkedHashMap`, `TreeMap`, `ConcurrentHashMap`.

---

## 4. ArrayList — detailed

**Definition:** `ArrayList<E>` is a resizable array implementation of `List<E>` backed by an array (`Object[] elementData`).

**Key properties:**

* Random access — `get(index)` is O(1).
* Backed by contiguous array (heap memory).
* Not synchronized (not thread-safe by default).
* Amortized `add(E)` is O(1) (occasional O(n) when resizing).
* `remove(index)` is O(n) because elements must be shifted.

**Capacity growth (implementation detail):**

* When capacity needs to grow, new capacity ≈ `oldCapacity + (oldCapacity >> 1)` (i.e., 1.5× old). This is Java's `ArrayList` policy (fast growth but avoids too-large jumps). Initial default capacity = 10 (for `new ArrayList()`; internal details vary by JDK but behavior above is standard).

**Common methods:**

* `add(E)`, `add(int index, E)`, `get(int index)`, `set(int index, E)`, `remove(int index)`, `remove(Object o)`, `size()`, `ensureCapacity(int)`.

**Memory layout (conceptual):**

```
ArrayList object
  - int size
  - Object[] elementData (length = capacity)
     elementData[0] -> obj0
     elementData[1] -> obj1
     ...
```

**Iteration behavior:**

* Iterator is *fail-fast* — if the list is structurally modified after iterator creation (except via iterator.remove()), the iterator throws `ConcurrentModificationException`. This is a best-effort check (modCount) and not a synchronization guarantee.

**When to use ArrayList:**

* Frequent random access, mostly append operations, single-threaded or externally synchronized.

---

## 5. Vector — detailed

**Definition:** `Vector<E>` is a legacy synchronized resizable array class that implements `List<E>`. It predates the modern Collections Framework (introduced in Java 1.0). `Vector` methods are synchronized, offering thread-safety at the method level.

**Key properties:**

* Thread-safe via method-level synchronization (most public methods are `synchronized`).
* Slightly older growth policy: Vector historically doubled capacity (`newCapacity = oldCapacity * 2`) or used an `capacityIncrement` if provided (legacy behavior). Exact behavior depends on constructor used and JDK version, but doubling was typical.
* Because of synchronization overhead and coarse-grained locking, `Vector` can be slower than `ArrayList` in single-threaded contexts. For concurrency, prefer `Collections.synchronizedList(...)` or concurrent collections (`CopyOnWriteArrayList`, `ConcurrentHashMap`), depending on use case.

**Constructors:**

* `new Vector<>()` default capacity 10.
* `new Vector(int initialCapacity)`
* `new Vector(int initialCapacity, int capacityIncrement)` — legacy: if `capacityIncrement > 0`, grow by that; otherwise double.

**Example usage:**

```java
List<Integer> v = new Vector<>();
v.add(10); // synchronized internally
```

**Iteration and thread-safety caveats:**

* Iterating a `Vector` with a for-each loop still uses an iterator that is fail-fast. Structural modifications by another thread may still throw `ConcurrentModificationException`.
* Method-level synchronization does not protect compound operations unless the caller synchronizes externally:

  ```java
  // not safe without external synchronization for check-then-act
  if (!v.contains(x)) { v.add(x); }
  ```

  Two threads may both pass the `contains` check and both add; to make it atomic, synchronize on the list or use concurrent structures.

**When to use Vector:**

* Rarely recommended nowadays. Use `ArrayList` or concurrency-aware collections. Use `Vector` only for legacy code requiring binary compatibility.

---

## 6. Enum — deep

**Definition:** An `enum` is a special Java type used to define a fixed set of constants. Each enum constant is a singleton instance of the enum type. Enums are full-fledged classes; they can have fields, methods, constructors, and implement interfaces. Enum constructors are implicitly `private` (or package-private) — you cannot instantiate enums from outside.

**Why enums over `int` constants:**

* Type-safety (compiler checks).
* Namespace (grouped constants).
* Can add methods and fields.
* Built-in methods: `values()`, `valueOf(String)`, `ordinal()`.

**Example (improved and corrected):**

```java
package com.adarsh.enumexamples;

public class Basic {
    interface A { void hello(); }

    enum Week implements A {
        Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday;

        // enum constructor (implicitly private)
        Week() {
            System.out.println("Constructor called for " + this);
        }

        @Override
        public void hello() {
            System.out.println("hey how are you from " + this);
        }

        // You can also add fields and methods:
        private int workHours = 8;
        public int getWorkHours() { return workHours; }
    }

    public static void main(String[] args) {
        Week week = Week.Monday;
        week.hello();
        System.out.println(Week.valueOf("Monday"));
        for (Week day : Week.values()) System.out.println(day + " ordinal:" + day.ordinal());
    }
}
```

**Important enum details:**

* Enum constants are `public static final` instances, created when the enum class is loaded.
* `ordinal()` returns the position (0-based) of the constant — use with care (not stable across reordering).
* `values()` returns array of all constants in declaration order.
* `valueOf("Name")` returns the enum constant by name (throws `IllegalArgumentException` if not found).
* You can implement interfaces in `enum`s but cannot extend other classes (enum already extends `java.lang.Enum`).
* Enums are serializable by default; the serialization mechanism ensures singleton property.

**Memory/initialization:**

* Enum constants are initialized when the enum class is loaded — constructors run once per constant.

**Best practices:**

* Prefer enums over `int`/`String` constants for fixed sets of values.
* Don’t rely on `ordinal()` for persistence; store explicit fields if you need stable codes.

---

## 7. Map family — short but essential

**Key Map implementations:**

* `HashMap<K,V>` — unsynchronized, O(1) average for get/put, uses hashing. Null keys/values allowed (one null key, multiple null values).
* `LinkedHashMap<K,V>` — maintains insertion (or access) order; useful for LRU caches (access-order mode).
* `TreeMap<K,V>` — sorted map, implemented as Red-Black tree. Keys must be `Comparable` or supply a `Comparator`. Put/get O(log n).
* `ConcurrentHashMap<K,V>` — thread-safe, highly concurrent, segmentation/lock-free improvements; no null keys or values.

**Map vs Collection:**

* `Map` stores key→value pairs; its `entrySet()`, `keySet()`, and `values()` provide views (Collections) to iterate.

---

## 8. Iterators — fail-fast vs fail-safe

* **Fail-fast iterators** (most Collections): detect structural modifications and throw `ConcurrentModificationException`. They rely on a `modCount` tracked by the collection and checked during iteration.
* **Fail-safe iterators** (concurrent collections like `CopyOnWriteArrayList`, `ConcurrentHashMap`): iterate over a snapshot or use weakly consistent traversal; they do not throw `ConcurrentModificationException` and may or may not reflect concurrent changes.

**Example: CopyOnWriteArrayList**

* Writes create a new internal array (good for mostly-read, rarely-modified scenarios).
* Iterators iterate over a snapshot — no concurrent modification exceptions, but iterator won't see subsequent updates.

---

## 9. Complexity cheat-sheet (average-case, typical implementations)

* `ArrayList`: get O(1), add (append) amortized O(1), add(index) O(n), remove(index) O(n), contains O(n).
* `LinkedList`: get O(n), addFirst/addLast O(1), remove O(1) if node known, contains O(n).
* `HashSet` / `HashMap`: get/put/remove average O(1), worst-case O(n) if many collisions (modern Java mitigates with treeification).
* `TreeSet` / `TreeMap`: get/put/remove O(log n).
* `PriorityQueue`: offer/poll O(log n), peek O(1).
* `Vector`: similar to ArrayList but synchronized (method-level locking).

---

## 10. Code examples (cleaned)

### ArrayList example

```java
import java.util.*;

public class ArrayListExample {
    public static void main(String[] args) {
        List<String> a = new ArrayList<>();
        a.add("apple");
        a.add("banana");
        System.out.println(a.get(1)); // banana
        a.remove("apple");
        for (String s : a) System.out.println(s);
    }
}
```

### Vector example (legacy)

```java
import java.util.*;

public class VectorExample {
    public static void main(String[] args) {
        Vector<Integer> v = new Vector<>();
        v.add(45); v.add(5); v.add(15);
        System.out.println(v);
        // synchronized but iteration still fail-fast
    }
}
```

### Enum example (already above)

---

## 11. Best practices & recommendations

* Prefer **ArrayList** for general-purpose lists (single-threaded). Use `Collections.synchronizedList(...)` or explicit synchronization if you need thread-safety for ArrayList.
* Prefer **CopyOnWriteArrayList** for lists where traversal vastly outnumbers mutations (e.g., event listeners).
* For concurrent maps, use `ConcurrentHashMap` rather than `HashMap` wrapped in `synchronizedMap` for better concurrency.
* Use **LinkedHashMap** for predictable iteration order, or to implement LRU caches (with `removeEldestEntry` override).
* Use **TreeMap/TreeSet** when you need sorted order (log n operations).
* Avoid `Vector` in new code; it’s legacy.
* Prefer `enum` over integer or string constants for fixed sets.

---

## 12. Interview-style quick questions & answers

Q: When does `ArrayList` resize and what's its complexity?
A: It resizes when `size == capacity`. Growth is ~1.5× (old + old >> 1); append is amortized O(1) but resizing is O(n).

Q: Difference between `ArrayList` and `LinkedList`?
A: `ArrayList` is backed by array (random access O(1), shifting on insert/remove O(n)). `LinkedList` is doubly-linked (insert/remove at ends O(1), random access O(n)).

Q: What is fail-fast iterator?
A: Iterator that throws `ConcurrentModificationException` if the collection is structurally modified after iterator creation (best-effort detection via modCount).

Q: Why not use `Vector`?
A: `Vector` uses coarse-grained method-level synchronization; prefer modern concurrent collections or synchronized wrappers for more appropriate concurrency control.

Q: Can enum implement interfaces?
A: Yes — enums can implement interfaces and provide method implementations.

---

## 13. Final ASCII flowchart of Collections & Maps (expanded)

```
Collection<E>                           Map<K,V>
  |                                       |
  |-- List<E>                             |-- SortedMap<K,V>
  |    |-- ArrayList<E>                   |     |-- TreeMap<K,V>
  |    |-- LinkedList<E>                  |
  |    |-- Vector<E>                      |-- HashMap<K,V>
  |    |-- CopyOnWriteArrayList<E>        |-- LinkedHashMap<K,V>
  |
  |-- Set<E>
  |    |-- HashSet<E>
  |    |-- LinkedHashSet<E>
  |    |-- TreeSet<E> (SortedSet/NavigableSet)
  |
  |-- Queue<E>
       |-- Deque<E>
           |-- ArrayDeque<E>
           |-- LinkedList<E> (also implements Deque)
       |-- PriorityQueue<E>

Utilities:
- java.util.Collections (sorting, searching, synchronized wrappers)
- java.util.Arrays (arrays ↔ lists, sort)
Concurrency:
- java.util.concurrent (ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue)
```

---
