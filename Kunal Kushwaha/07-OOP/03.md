
# Contents

1. Quick summary of the four pillars
2. INHERITANCE — deep dive

   * concept, syntax, constructor call order, `super`, visibility, types, why private matters
   * example classes (Box / BoxWeight) with code and detailed constructor chaining flow diagrams
   * rules, pitfalls, and best practices (Liskov)
3. POLYMORPHISM — deep dive

   * compile-time (overloading) vs runtime (overriding)
   * dynamic method dispatch, binding, `final` & `static` effects
   * examples and diagrams showing which method runs with different reference/object combos
4. ENCAPSULATION — deep dive

   * information hiding, access modifiers, getters/setters, immutability patterns
   * code and memory/behavior consequences
5. ABSTRACTION — deep dive

   * abstract classes vs interfaces, use-cases, when to choose which
   * examples and design rationale
6. Relationship & differences: Encapsulation vs Abstraction (clear explanation)
7. Java specifics and related topics (Object class, `toString()`, `hashCode()`, `equals()`, `final`, `static`, `this`, `super`, packages, import note)
8. Common interview patterns / sample questions, pitfalls, complexity notes
9. Compact quick reference table
10. Appendix: ASCII diagrams (constructor chaining, method dispatch, memory layout for inheritance, access rules)

---

# 1. Quick summary of the four pillars

* **Abstraction** — expose *what* an object does, hide *how* it does it (interfaces/abstract classes).
* **Encapsulation** — bundle data + methods, control access to internal state using access modifiers; enforce invariants.
* **Inheritance** — a class (child/subclass) can acquire fields and methods from another class (parent/superclass) using `extends`. Enables reuse.
* **Polymorphism** — same name, multiple forms: compile-time (overloading) and runtime (overriding). Runtime polymorphism allows code to operate on the superclass type while using subclass behavior.

---

# 2. INHERITANCE — Deep dive

## Definition (concise)

Inheritance is a mechanism where a class (child/subclass) **derives** from another class (parent/superclass). The child inherits accessible fields and methods of the parent and can add or override behavior.

## Why use inheritance

* Reuse code: common logic sits in parent, specialized logic in children.
* Polymorphism: treat different subclasses uniformly via a superclass reference.
* Model "is-a" relationships: `Car` is-a `Vehicle`.

## Syntax

```java
class Parent { ... }
class Child extends Parent { ... }
```

## Visibility & inheritance

* `private` members of parent are **not directly accessible** in child. They still exist in the object but are accessible via parent’s public/protected methods (getters/setters).
* `protected` members are accessible in child classes (and same package).
* `public` members are accessible everywhere.
* Package-private (no modifier) are accessible only within the same package.

## Constructors & initialization order (critical)

When creating `new Child(...)`, JVM initializes in this order:

1. Memory for the whole object (both parent & child fields) is allocated on the heap; all fields set to default values (`0`, `false`, `null`, etc.).
2. The **parent constructor(s)** run first (topmost superclass down to immediate parent). This happens because every constructor implicitly or explicitly calls `super(...)` as its first statement.
3. Parent fields initialized (instance initializers and instance field initializers execute before parent constructor body).
4. After parent constructor completes, child instance initializers and field initializers execute, then child constructor body executes.

So chain looks like: `Object` → ... → `Parent` → `Child`.

### `super()` and `this()` rules

* `super(...)` calls parent constructor and **must be first statement** in a constructor if used.
* `this(...)` calls another constructor in the same class and also **must be first** if present.
* You cannot have both as first; you can call `this(...)` which eventually may call `super(...)`.

### Example — Box / BoxWeight (refined, complete)

```java
// Box.java
package com.adarsh.properties.inheritance;

public class Box {
    private double l;  // private: not visible to subclasses directly
    double h;           // package-private
    double w;           // package-private

    // default constructor
    Box() {
        this.l = -1; this.h = -1; this.w = -1;
    }
    // cube
    Box(double side) {
        this.l = side; this.h = side; this.w = side;
    }
    // parameterized
    Box(double l, double h, double w) {
        System.out.println("Box class constructor");
        this.l = l; this.h = h; this.w = w;
    }
    // copy
    Box(Box old) {
        this.l = old.l; this.h = old.h; this.w = old.w;
    }

    public double getL() { return l; } // getter to access private l
}
```

```java
// BoxWeight.java
package com.kunal.properties.inheritance;

import com.adarsh.properties.inheritance.Box;

public class BoxWeight extends Box {
    double weight;

    BoxWeight() {
        super(); // optional, implicit
        this.weight = -1;
    }

    BoxWeight(double side, double weight) {
        super(side); // calls Box(double)
        this.weight = weight;
    }

    BoxWeight(double l, double h, double w, double weight) {
        super(l, h, w); // MUST be first
        this.weight = weight;
    }

    BoxWeight(BoxWeight other) {
        super(other); // Box(Box) copy parent fields
        this.weight = other.weight;
    }
}
```

### Constructor chaining ASCII flow

```
new BoxWeight(2,3,4,8)
  -> BoxWeight(double,double,double,double) (child constructor)
     first line: super(2,3,4)
        calls -> Box(double,double,double) (parent constructor)
           (parent fields initialized here)
        return to child constructor
     then child sets weight = 8
```

## Polymorphic reference & access rules

Given:

```java
Box b = new BoxWeight(2,3,4,8);
```

* The **reference type** (`Box`) controls **which members are accessible at compile time**.
* The **actual object** (`BoxWeight`) controls **which overridden methods run at runtime**.
* Fields are **not polymorphic** — field access is determined by the reference type, not the object type.

So:

* `b.getL()` — compiles and calls Box.getL() which returns parent's value (but data inside object is from child/parent combined).
* `b.weight` — compile error (Box reference has no `weight` member).
* If `Box` had a method `describe()` which `BoxWeight` overrides, `b.describe()` would execute `BoxWeight`’s version at runtime (dynamic dispatch).

## Types of inheritance (as applicable to Java)

* Single: `Child extends Parent`
* Multilevel: `A -> B -> C` (A parent of B, B parent of C)
* Hierarchical: One parent, many children
* Java does **not support multiple class inheritance** (class cannot extend more than one class). Use interfaces for multiple-type behavior.

## `super` keyword deeper

* `super` refers to the immediate parent object part. It can be used:

  * call parent constructor: `super(args);`
  * access parent methods: `super.method()`
  * access parent fields if visible: `super.someField` (only if not private).
* You **cannot** use `super` in static context (no instance to refer to).

## Liskov Substitution Principle (LSP) — practical note

Subtypes must preserve behavior so that code expecting the parent can work with the subtype. When overriding methods, do not weaken preconditions or strengthen postconditions — preserve contracts. This avoids surprising behavior when using polymorphism.

## Pitfalls & best practices

* Don’t expose parent internals via protected fields unless necessary; prefer `private` fields + protected/public getters/setters.
* Avoid deep inheritance trees; prefer composition over inheritance when behavior is orthogonal.
* Respect encapsulation — override methods carefully; keep invariants intact.

---

# 3. POLYMORPHISM — Deep dive

## Two main kinds

1. **Compile-time (static) polymorphism** — method overloading (same name, different parameter lists). Decision happens at compile time.
2. **Runtime (dynamic) polymorphism** — method overriding (subclass provides implementation for method in superclass). Decision happens at runtime by dynamic method dispatch.

## Overloading (compile-time)

```java
class Calc {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
}
```

* Compiler picks the correct method based on reference types and argument types.
* Overloading can change return type (only) if different parameter lists — return type alone cannot distinguish overloads.

## Overriding (runtime)

```java
class Shape {
    void area() { System.out.println("I am shape"); }
}
class Circle extends Shape {
    @Override
    void area() { System.out.println("pi * r * r"); }
}
```

* If `Shape s = new Circle(); s.area();` → prints Circle’s area method.
* Overriding requires same signature (name + parameter types); return type can be covariant (a subtype for reference return types).

## Dynamic Method Dispatch (how JVM chooses method)

* At compile time, the compiler verifies the method exists for the reference type.
* At runtime, JVM uses the actual object's vtable (virtual method table) to choose the correct overridden implementation.
* Only instance (non-static) methods are dispatched dynamically.

### `final` and `static` effect

* `final` methods cannot be overridden — compile-time prevents override.
* `static` methods are not instance methods: they are class-level and **are not polymorphic**. If you declare `static void greeting()` in parent and child, you have method hiding, not overriding. Which method is called depends on the reference type at compile time.

## Early binding vs Late binding

* Early (static) binding: compiler resolves call (overloaded methods, `static` methods, `final` methods).
* Late (dynamic) binding: runtime resolves call using object type (overridden instance methods).

## Example showing behavior and rules

```java
class Parent {
    void show() { System.out.println("Parent show"); }
    static void staticShow() { System.out.println("Parent static"); }
}

class Child extends Parent {
    @Override
    void show() { System.out.println("Child show"); }
    static void staticShow() { System.out.println("Child static"); }
}

Parent p = new Child();
p.show();          // prints "Child show" (runtime)
p.staticShow();    // prints "Parent static" (compile-time binding)
```

## ASCII to show dispatch

```
Reference type: Parent
Actual object:   Child

p.show()  -> at compile time: 'show' exists in Parent so call allowed.
           at runtime: object is Child => Child.show() invoked (dynamic dispatch)

p.staticShow() -> compiled as Parent.staticShow(); no polymorphism
```

---

# 4. ENCAPSULATION — Deep dive

## Definition

Encapsulation is the bundling of data (fields) and methods that operate on the data into a single unit (class) and controlling access to the internal representation.

## Goals

* Protect object’s internal state from inappropriate external changes.
* Provide well-defined interfaces (APIs) to interact with the object.
* Maintain invariants.

## Mechanisms in Java

* Access modifiers: `private`, `protected`, package-private (default), `public`.
* Use of getters and setters to control access (validation logic, immutability).
* `final` fields for immutable once-initialized data.
* Make fields `private` and expose only what’s needed.

## Example — safe Student class with encapsulation

```java
public class Student {
    private final int roll;     // immutable after construction
    private String name;
    private float marks;

    public Student(int roll, String name, float marks) {
        this.roll = roll;
        setName(name);
        setMarks(marks);
    }

    public int getRoll() { return roll; }

    public String getName() { return name; }
    public void setName(String name) {
        if (name == null || name.isBlank()) throw new IllegalArgumentException("Invalid name");
        this.name = name;
    }

    public float getMarks() { return marks; }
    public void setMarks(float marks) {
        if (marks < 0 || marks > 100) throw new IllegalArgumentException("Invalid marks");
        this.marks = marks;
    }
}
```

* `roll` is immutable, encapsulated with a getter only.
* Name and marks validated through setters to preserve object invariants.

## Benefits

* Easier to maintain and reason about code.
* Ability to change internal representation without affecting external code.
* Enforces correct usage via validation.

## Encapsulation vs Immutability

* Encapsulation is about access control and bundling.
* Immutability is a design that ensures object state cannot change after construction (useful for thread-safety).

---

# 5. ABSTRACTION — Deep dive

## Definition

Abstraction means representing essential features without including implementation details. Focus on **what** an object does rather than **how** it does it.

## Mechanisms in Java

* **Abstract classes** (use `abstract`): can contain abstract methods (no body) and concrete methods. Use when you need partial implementation or shared code and want to force subclasses to implement some methods.
* **Interfaces**: define a contract. Prior to Java 8, interfaces had only abstract methods; Java 8+ allows default and static methods; Java 9+ allows private methods inside interfaces.

## When to use abstract class vs interface

* Use **interface** when you need to define a contract and allow multiple unrelated classes to implement it (multiple inheritance of type).
* Use **abstract class** when you have an "is-a" relationship and want to share common code/state among subclasses.

## Example — abstraction using interface

```java
public interface Shape {
    double area();      // abstract method
    double perimeter();
}

public class Circle implements Shape {
    private double radius;
    public Circle(double radius) { this.radius = radius; }
    public double area() { return Math.PI * radius * radius; }
    public double perimeter() { return 2 * Math.PI * radius; }
}
```

Code using abstraction:

```java
List<Shape> shapes = List.of(new Circle(2), new Square(3));
for (Shape s : shapes) { System.out.println(s.area()); }
```

Caller uses `Shape` interface — doesn't need to know the implementation details.

---

# 6. Encapsulation vs Abstraction — clear comparison

* **Encapsulation** (how): Concretely packages implementation and data together and restricts access using access modifiers. It’s about *data hiding and controlling access*. Example: private fields, public getters/setters.
* **Abstraction** (what): Focuses on presenting a simple interface while hiding complex underlying implementation. Example: `List` interface, you use `add()` without caring how it stores data.

Another way:

* Encapsulation is *technique* (language mechanism) to achieve data hiding.
* Abstraction is *design principle* (model) to manage complexity by exposing essential behavior and hiding details.

---

# 7. Java specifics & related topics

## `Object` class

* Every Java class implicitly extends `Object` if no other superclass specified.
* Important methods to consider and often override:

  * `public String toString()` — default prints `ClassName@hexHash`.
  * `public boolean equals(Object o)` — default compares references; often overridden for value equality.
  * `public int hashCode()` — must be consistent with equals if equals overridden.
  * `protected void finalize()` — deprecated / not reliable; avoid relying on it for cleanup; use `try-with-resources`, `AutoCloseable`, or explicit resource management.

## Why `obj` prints `com.adarsh@hshsu88`

Default `toString()` returns:

```
getClass().getName() + '@' + Integer.toHexString(hashCode())
```

So `com.adarsh@hshsu88` is `ClassName@hex(hashCode)`.

## `final` keyword

* `final` variable: cannot be reassigned.
* `final` method: cannot be overridden by subclasses.
* `final` class: cannot be subclassed.
* `final` reference to object: cannot change reference, but object's internal state can change unless those fields are also final/immutable.

## `static` deep note

* `static` members belong to class metadata (stored in method area / metaspace), not per-instance.
* Use `static` for data/methods that are common across all instances (e.g., counters, utility methods).
* `static` contexts cannot access `this` or `super` because they are not tied to a specific object.

## `this` & `super` private implementation nuance

* When an instance method is invoked, JVM passes an implicit reference to the current object — that's what `this` points to.
* `this` lets you disambiguate between local and instance variables.
* `super` is like `this` but references the parent portion; it is used primarily to call parent constructor or parent methods.

## Multiple inheritance & interfaces

* Java prevents multiple inheritance of implementation to avoid the "diamond problem".
* Interfaces provide multiple-type inheritance (a class can implement many interfaces).
* From Java 8 onwards interfaces can have `default` methods (with implementation) — if two interfaces provide conflicting default methods, implementor must override.

## Overriding equals/hashCode

* If you override `equals()`, always override `hashCode()` to obey the contract.
* `equals()` should be:

  * reflexive, symmetric, transitive, consistent, return false for null.
* `hashCode()` should return the same int for equal objects.

---

# 8. Common interview patterns & sample questions

Important topics you must be ready to explain and/or code:

* Constructor chaining and order of initialization (draw flow).
* `super` vs `this`.
* Overloading vs overriding examples and tell which binding is used.
* Why `main` is static, and consequences of trying non-static main (JVM error).
* How `static` methods are resolved vs instance methods.
* Implement Singleton (eager, lazy, thread-safe with double-checked locking, enum-based).
* When to use `abstract class` vs `interface`.
* Demonstrate encapsulation: show a class with `private` fields and validation in setters.
* Explain Liskov Substitution with a failing example (e.g., Rectangle vs Square) and why composition is better in such cases.

### Example interview tasks (practice)

1. Show constructor call sequence (create class A -> B -> C and print messages).
2. Implement a polymorphic `draw()` hierarchy and a factory method that returns `Shape`.
3. Implement immutable `Person` class (all `final` fields, no setters, defensive copies).
4. Write a thread-safe Singleton (explain `volatile`, `synchronized`, double-checked locking).
5. Show an example where overriding breaks LSP and propose a fix.

---

# 9. Compact quick reference table

| Concept             | Key property                      | Example/Effect                 |
| ------------------- | --------------------------------- | ------------------------------ |
| `extends`           | Inherit fields & methods          | `class B extends A`            |
| `super()`           | call parent constructor           | first statement in child ctor  |
| `this()`            | call sibling constructor          | first statement in ctor        |
| `private`           | not visible in subclass           | use getters                    |
| `protected`         | visible in subclass & package     | accessible by subclass         |
| `static`            | class-level, no `this`            | `static int count`             |
| `final`             | prevents override/reassign/extend | `final class`                  |
| Overloading         | same name diff params             | compile-time resolution        |
| Overriding          | same signature                    | runtime resolution             |
| `Object.toString()` | default class@hex                 | override for meaningful string |

---

# 10. Appendix: ASCII Diagrams

## A. Constructor chaining & memory layout (object with parent portion)

```
Stack                 Heap (object)
----------------    -----------------------------------
ref: boxWeight --->  [ BoxWeight object ]
                     [ Box fields: l | h | w ]   <- parent fields
                     [ BoxWeight fields: weight ] <- child field

Creation: new BoxWeight(2,3,4,8)
  JVM:
   - allocate memory for full object (Box portion + BoxWeight portion)
   - default init: l=0.0,h=0.0,w=0.0,weight=0.0
   - call BoxWeight(...) -> first statement super(2,3,4)
       -> Box(2,3,4) executes -> set parent's fields
   - return to BoxWeight ctor -> set weight=8
```

## B. Method dispatch diagram (reference vs object)

```
Parent ref (compile-time)  Actual object (runtime)
----------------------     ---------------------------
Parent p = new Child();    object: [Child data + vtable]
p.show();  -> compiler ensures Parent has show()
            runtime consults vtable of actual object -> Child.show() runs

If show() is static:
p.staticShow(); -> static binding to Parent.staticShow() at compile time
```

## C. Field access vs method override

```
class Parent { int x = 10; void show() { print(x); } }
class Child  { int x = 20; void show() { print(x); } }

Parent p = new Child();
print(p.x);  // prints 10 (field resolved by reference type)
p.show();    // prints 20 (method resolved by object type)
```

## D. `toString()` default format

```
obj.toString() -> return getClass().getName() + "@" + Integer.toHexString(hashCode())
example: com.adarsh.ClassName@1a2b3c
```

---

# Extra: Singleton thread-safe pattern (safe example)

```java
public class Singleton {
    private static volatile Singleton instance; // volatile for visibility
    private Singleton() { }
    public static Singleton getInstance() {
        if (instance == null) {                      // first check (no lock)
            synchronized (Singleton.class) {
                if (instance == null) {              // second check (with lock)
                    instance = new Singleton();      // initialize
                }
            }
        }
        return instance;
    }
}
```

Alternative: Enum Singleton (simplest thread-safe):

```java
public enum SingletonEnum {
    INSTANCE;
    // methods...
}
```

---

# Closing notes (best practices & summary)

* Prefer composition over inheritance when you only need to reuse functionality rather than enforce an “is-a” relation. Composition reduces coupling and increases flexibility.
* Keep fields `private` and provide controlled accessors. This reduces bugs, improves maintainability, and allows later refactorings.
* Override `toString()`, `equals()`, and `hashCode()` sensibly when your class represents value-type semantics.
* Use `final` to prevent unwanted extension or modification where appropriate.
* Understand the difference between reference type and object type — it drives which members you can access and which methods run.
* For concurrency and singletons, prefer language-supported patterns (`enum singleton`) or correct locking with `volatile`.

