
# Access modifiers, packages, and `Object` ‚Äî Extremely detailed notes

Contents

1. Access modifiers (detailed rules, examples, subtle cases)
2. Packages and import (user-defined, built-in, static import, top-level class rules)
3. `java.lang.Object` (methods, contracts, correct overrides with examples)
4. `equals()` vs `==`, `hashCode()` contract, sample implementations
5. `toString()`, `clone()`, `finalize()` (status and alternatives)
6. `instanceof` vs `getClass()` differences
7. Reflection note: accessing private members (how and caveats)
8. ASCII diagrams: object memory layout and access visualization
9. Quick reference tables and interview-style pitfalls & best practices

---

## 1. Access modifiers (detailed)

Java provides four *member* access levels (for classes, fields, methods, constructors ‚Äî with slightly different rules for top-level types):

* **public** ‚Äî accessible from any other class, any package.
* **protected** ‚Äî accessible within the same package, and accessible to subclasses (even if subclass is in a different package). Important nuance: access from *outside package* to a protected member is allowed **only from inside the subclass‚Äôs code** (i.e., through inheritance), not via arbitrary object references.
* **(default) package-private** ‚Äî no modifier; accessible only within the same package.
* **private** ‚Äî accessible only within the same class.

### Top-level class rule

A *top-level* class (a class declared directly in a .java file, not nested) may be either:

* `public` (name must match file name), or
* package-private (no modifier).
  A top-level class cannot be `private` or `protected`.

---

### Correct access table

Legend: `+` accessible, `-` not accessible. ‚ÄúSubclass (Different package)‚Äù column assumes access code is *inside the subclass*.



```
+------------------+--------+---------+------------------+--------------------------+-----------------------+
| Access Modifier  | Class  | Package | Subclass (Same)  | Subclass (Different)     | World (Diff Package)  |
+------------------+--------+---------+------------------+--------------------------+-----------------------+
| public           |   +    |    +    |        +         |            +             |          +            |
+------------------+--------+---------+------------------+--------------------------+-----------------------+
| protected        |   +    |    +    |        +         |            +             |                       |
+------------------+--------+---------+------------------+--------------------------+-----------------------+
| default          |   +    |    +    |        +         |                          |                       |
| (no modifier)    |        |         |                  |                          |                       |
+------------------+--------+---------+------------------+--------------------------+-----------------------+
| private          |   +    |         |                  |                          |                       |
+------------------+--------+---------+------------------+--------------------------+-----------------------+
```

### üß© Column Explanations

| Column Header            | Meaning                                                                                                                                                          |
| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Class**                | Access from **within the same class** where the member (field, method, etc.) is declared. <br>üëâ Example: `this.variable` inside the same class.                 |
| **Package**              | Access from **another class in the same package**, but **not a subclass**. <br>üëâ Example: another class in the same folder/package accessing the member.        |
| **Subclass (Same)**      | Access from a **subclass (child class)** that‚Äôs in the **same package** as the parent class.                                                                     |
| **Subclass (Different)** | Access from a **subclass (child class)** that‚Äôs in a **different package** than the parent class.                                                                |
| **World (Diff Package)** | Access from a **non-subclass class in a different package** ‚Äî basically, from ‚Äúanywhere in the world.‚Äù <br>üëâ If a member is accessible here, it‚Äôs truly public. |

---


Notes and important subtleties:

* `protected` members are accessible in subclasses even when subclass is in a different package, **but only through the subclass‚Äôs inherited access**. You cannot access a protected member of an instance of the parent class from an unrelated class in a different package.

  * Example: `Parent p = new Parent(); p.protectedMember;` is illegal in a different package even from a subclass. Inside subclass code you can access `protectedMember` directly as if it were your own field (`this.protectedMember` or just `protectedMember`).
* Default/package-private means **same package only** ‚Äî subclasses in a different package cannot access package-private members.
* `private` is strictly limited to the same class ‚Äî not even subclasses can access private members directly.

### Example: protected nuance

```java
// package p1
package p1;
public class Parent {
    protected int x = 42;
}

// package p2
package p2;
import p1.Parent;

public class Child extends Parent {
    void test() {
        // allowed: subclass access to inherited protected field
        System.out.println(this.x);    // OK
    }

    void test2() {
        Parent p = new Parent();
        // p.x is NOT allowed here because we are outside p1 package and using a Parent reference
        // System.out.println(p.x); // compile error
    }
}
```

---

## 2. Packages and import

### What is a package

* A **package** is a namespace that groups related classes and interfaces and maps to directory structure on disk.
* Example: `package com.adarsh.utils;` corresponds to the folder `com/adarsh/utils/` and the file must be placed there (unless you use a custom build tool that maps differently).

### Naming convention

* Reverse domain name convention: e.g., `com.company.project.module`. This reduces naming collisions.

### `import` keyword

* `import java.util.ArrayList;` ‚Äî import a single class.
* `import java.util.*;` ‚Äî import all *type names* in the package (not subpackages).
* `import static java.lang.Math.PI;` ‚Äî static import of a static member; allows using `PI` directly.
* `java.lang` is implicitly imported in every Java source file; you do not need `import java.lang.String`.

### Static import caveat

* Use static import sparingly (e.g., for constants or utility functions) ‚Äî overuse harms readability.

### If classes are in the same package

* No import is necessary; code can refer to the other class by simple name.

### Top-level classes vs nested classes

* Nested (static inner) classes have fully-qualified names like `com.adarsh.Outer$Inner` at JVM level; source-level reference is `Outer.Inner`.

---

## 3. `java.lang.Object` ‚Äî root class

Every class in Java implicitly extends `Object` (unless it extends some other class, which itself ultimately extends `Object`). `Object` defines several fundamental methods. You should override some of them in your classes to provide meaningful behaviour.

### Important methods of `Object` (and correct behavior)

1. `public String toString()`

   * Default implementation: returns `getClass().getName() + "@" + Integer.toHexString(hashCode())`.
   * Best practice: override to return a readable representation of the object's state for debugging/logging.

2. `public boolean equals(Object obj)`

   * Default implementation (in `Object`) is reference equality (`this == obj`).
   * When overriding, follow the equals contract (see section below). If equals is overridden, you must also override `hashCode()`.

3. `public int hashCode()`

   * Default returns an integer; many JVMs base it on memory address or an internal id, but **the specification does not force any specific algorithm**. It must be consistent with `equals()`: equal objects must have equal hash codes. Non-equal objects can share hash codes (collisions allowed).

4. `protected Object clone() throws CloneNotSupportedException`

   * Default: performs a *shallow copy* if the object implements `Cloneable`. Otherwise it throws `CloneNotSupportedException`. To use clone, implement `Cloneable` and override clone to make it `public` and possibly perform deep copying.

5. `protected void finalize() throws Throwable`

   * Legacy finalizer method. It is **deprecated** and unreliable (no guarantees on when/if it runs). Do not rely on it for important cleanup. Use `AutoCloseable`/try-with-resources or `java.lang.ref.Cleaner` instead.

6. `public final Class<?> getClass()`

   * Returns run-time class of the object.

7. `public final void notify()/notifyAll()/wait()`

   * Thread primitives. Use higher-level concurrency constructs where possible.

---

## 4. `equals()` vs `==`, and `hashCode()` contract (detailed)

### `==` operator

* For reference types, `==` checks **reference identity** ‚Äî whether two references point to the same object instance.
* For primitives, `==` compares value.

### `equals(Object)` method

* Purpose: check *logical equality* ‚Äî override to compare objects by meaningful state.
* Contract (from Java spec):

  * Reflexive: `x.equals(x)` is true.
  * Symmetric: `x.equals(y)` iff `y.equals(x)`.
  * Transitive: if `x.equals(y)` and `y.equals(z)`, then `x.equals(z)`.
  * Consistent: repeated calls give same result if state unchanged.
  * Non-nullity: `x.equals(null)` must return false.

### `hashCode()` contract

* If `a.equals(b)` then `a.hashCode() == b.hashCode()`.
* If `!a.equals(b)`, hash codes *may* still be equal (collisions).
* Good hash functions spread objects across buckets to reduce collisions.

### Recommended equals/hashCode pattern

* Use `@Override`
* Use `instanceof` or `getClass()` depending on whether equality should allow subclass equality.
* Use `Objects.equals()` and `Objects.hash()` utilities for null-safety.

Example:

```java
public class ObjectDemo {
    private final int num;
    private final float gpa;

    public ObjectDemo(int num, float gpa) {
        this.num = num;
        this.gpa = gpa;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;                 // same reference
        if (o == null) return false;
        if (getClass() != o.getClass()) return false; // strict type check
        ObjectDemo that = (ObjectDemo) o;
        return this.num == that.num && Float.compare(this.gpa, that.gpa) == 0;
    }

    @Override
    public int hashCode() {
        return java.util.Objects.hash(num, gpa);
    }

    @Override
    public String toString() {
        return "ObjectDemo{num=" + num + ", gpa=" + gpa + "}";
    }
}
```

Notes:

* Use `Float.compare()` for floating-point comparisons in equals.
* Choose `getClass()` (strict) vs `instanceof` (allows subclass equality). Usually `getClass()` is safer unless you design for polymorphic equality.

---

## 5. `toString()`, `clone()`, `finalize()` details and modern alternatives

### `toString()`

* Default: `ClassName@hexHash`.
* Good override shows key fields; useful for debugging and logging.
* Example shown above.

### `clone()`

* Default `Object.clone()` does a shallow copy and is `protected`.
* To use clone:

  1. Implement `Cloneable` interface (a marker interface).
  2. Override `clone()` to make it `public` and handle deep copy if necessary.
* Example:

```java
public class Person implements Cloneable {
    private String name;
    private int[] scores;

    @Override
    public Person clone() {
        try {
            Person copy = (Person) super.clone();   // shallow
            copy.scores = this.scores.clone();      // make deep copy of array
            return copy;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(e);
        }
    }
}
```

* Many developers prefer copy constructors or static factory methods instead of `clone()` because `clone()` is error-prone.

### `finalize()`

* Not reliable, deprecated. Do not use `finalize()` for resource cleanup.
* Use `AutoCloseable` and try-with-resources:

```java
try (BufferedReader br = new BufferedReader(...)) {
    // use br
} // br.close() automatically called
```

* For rare cleanup tasks use `java.lang.ref.Cleaner` (post-Java 9 replacement).

---

## 6. `instanceof` vs `getClass()`

* `instanceof` checks if object is an instance of a given type or subtype (handles inheritance).

  * `if (o instanceof String)` true even if `o` is an instance of a subclass of `String` (String is final so no subclass example here).
* `getClass()` returns exact runtime class; `getClass() == OtherClass.class` is true only when classes are identical.
* Use `instanceof` if equality should accept subclasses; use `getClass()` for strict equality.

Example:

```java
if (o == this) return true;
if (!(o instanceof ObjectDemo)) return false;  // instanceof style
ObjectDemo other = (ObjectDemo) o;
```

---

## 7. Reflection: accessing private members (how & caveats)

* Java Reflection API can break encapsulation at runtime:

```java
Field f = SomeClass.class.getDeclaredField("privateField");
f.setAccessible(true);
Object value = f.get(someInstance);
```

* Caveats:

  * `setAccessible(true)` can be blocked by SecurityManager or module system in recent Java versions.
  * Use reflection only when necessary (testing frameworks, libraries). It defeats compile-time safety and encapsulation.

---

## 8. ASCII diagrams

### Stack / Heap object layout

```
Stack frame (main):
----------------------------
local variable: objRef --->  [Heap object: ObjectDemo]
                           +------------------------------+
                           | class: ObjectDemo            |
                           | num: 12 (private)           |
                           | gpa: 56.8f (private)        |
                           +------------------------------+
```

### equals/hashCode flow (call diagram)

```
obj1.equals(obj2)  ->  obj1.equals method runs:
   1) check if this == obj2?
   2) check obj2 null?
   3) check same class / instanceof?
   4) cast and compare fields
If equals true then obj1.hashCode() == obj2.hashCode() must hold.
```

### protected access nuance (package and subclass)

```
Package p1 has Parent with protected x.
Package p2 has Child extends Parent.

Within Child (p2):
   this.x  // allowed
Within unrelated class in p2:
   Parent p = new Parent();
   p.x // NOT allowed (even though both p2 package classes, Parent in p1)
```

---

## 9. Quick reference and interview pitfalls

### Common mistakes you had in rough notes (corrected)

* You wrote `protected` allows access from subclass in other package ‚Äî correct ‚Äî BUT you must emphasise the *inheritance context*. Accessing `parentProtected` on a `Parent` reference from outside the package is **not** allowed.
* You assumed `hashCode()` is the memory address ‚Äî not guaranteed. Some JVMs derive from internal address but JVM is free to choose algorithm.
* `finalize()` is not reliable ‚Äî prefer `try-with-resources` and `Cleaner`.
* `clone()` requires `Cloneable` and typically needs a public override to be usable.
* Top-level classes cannot be `private` or `protected`.
* `import java.lang;` is incorrect ‚Äî you cannot import a package; `java.lang` is implicitly available; `import java.lang.*;` is meaningless (already implicit).

  * Correct usage: `import java.util.ArrayList;` or `import java.util.*;`.

### Common interview tasks

* Implement `equals()` and `hashCode()` correctly for a class with multiple fields.
* Explain and show `protected` access with code in different packages.
* Show the difference between `==` and `.equals()` with examples.
* Demonstrate a safe copy (copy constructor vs `clone()`), and discuss deep vs shallow copy.

---

## 10. Full corrected example class (complete, realistic)

```java
package com.example;

import java.util.Objects;

public final class Student {
    private final int roll;            // immutable
    private String name;
    private float marks;

    public Student(int roll, String name, float marks) {
        if (name == null || name.isBlank()) throw new IllegalArgumentException("Name required");
        if (marks < 0f || marks > 100f) throw new IllegalArgumentException("Marks must be between 0 and 100");
        this.roll = roll;
        this.name = name;
        this.marks = marks;
    }

    public int getRoll() { return roll; }

    public String getName() { return name; }
    public void setName(String name) {
        if (name == null || name.isBlank()) throw new IllegalArgumentException("Name required");
        this.name = name;
    }

    public float getMarks() { return marks; }
    public void setMarks(float marks) {
        if (marks < 0f || marks > 100f) throw new IllegalArgumentException("Marks must be between 0 and 100");
        this.marks = marks;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return roll == student.roll &&
               Float.compare(student.marks, marks) == 0 &&
               Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(roll, name, marks);
    }

    @Override
    public String toString() {
        return "Student{" + "roll=" + roll + ", name='" + name + '\'' + ", marks=" + marks + '}';
    }
}
```

---

### Final recommendations / best practices

* Make fields `private` by default and provide controlled accessors.
* Use `final` for fields that should not change after construction.
* Override `toString()`, `equals()`, `hashCode()` thoughtfully; follow the contracts.
* Prefer copy constructors or factory methods to `clone()`; if you use `clone()`, implement `Cloneable` correctly and handle deep copies explicitly.
* Avoid `finalize()`; use try-with-resources and `Cleaner`.
* Use packages with a clear structure and follow naming conventions (`com.company.module`).
* Use `protected` carefully; prefer `private + protected getters` when you want to keep control but allow subclasses to read values.

---

